#include <Arduino.h>
#include <stdint.h>
#include <driver/ledc.h>
#include "config.h"
#include "AdafruitIO_WiFi.h"

#define sensor_pin 34
#define bot1 23
#define led_v 26
#define led_a 27
#define led_r 14
#define servo_pin 12

AdafruitIO_Feed* feed_proyecto = io.feed("Proyecto");
#define IO_LOOP_DELAY 5000UL
unsigned long lastUpdate = 0; 

int sensor_val= 0;
float temp= 0.0;
float temp_disp= 0.0;
int bot_state= 0;
int last_bot_state= 0;
unsigned long last_time= 0;
unsigned long deb_delay= 50;

int led_v_pwm= 0;
int led_a_pwm= 0;
int led_r_pwm= 0;

const int ch_servo= 3;
const int servo_freq= 50;
const int servo_res= 16;
const int servo_min_us= 500;
const int servo_max_us= 2500;

static inline uint32_t usToDuty(int microseconds) {
  const uint32_t period_us = 20000UL;
  const uint32_t maxDuty   = (1UL << servo_res) - 1UL;
  return (uint32_t)(((uint64_t)microseconds * maxDuty) / period_us);
}

static inline void writeServoAngle(float angle_deg) {
  if (angle_deg < 0) angle_deg = 0;
  if (angle_deg > 180) angle_deg = 180;
  int pulse_us = servo_min_us + (int)((servo_max_us - servo_min_us) * (angle_deg / 180.0f));
  ledcWrite(ch_servo, usToDuty(pulse_us));
}

#define COMMON_CATHODE 1

const int dA = 2;   
const int dB = 4;
const int dF = 22;
const int dG = 13;
const int dE = 5;
const int dD = 18;
const int dC = 19;
const int dP = 21;

const int dig1 = 33;
const int dig2 = 25;
const int dig3 = 32;

#define seg_on   (COMMON_CATHODE ? HIGH : LOW)
#define seg_off  (COMMON_CATHODE ? LOW  : HIGH)
#define dig_on   (COMMON_CATHODE ? HIGH : LOW)
#define dig_off  (COMMON_CATHODE ? LOW  : HIGH)

volatile uint8_t disp_digits[3] = { 0, 0, 0 };
volatile bool    disp_dp[3]     = { false, false, false };

hw_timer_t*       dispTimer = nullptr;
portMUX_TYPE      dispMux   = portMUX_INITIALIZER_UNLOCKED;
volatile uint8_t  currentDigit = 0;

static inline void setSegments(bool a,bool b,bool c,bool d,bool e,bool f,bool g,bool dp) {
  digitalWrite(dA, a ? seg_on : seg_off);
  digitalWrite(dB, b ? seg_on : seg_off);
  digitalWrite(dC, c ? seg_on : seg_off);
  digitalWrite(dD, d ? seg_on : seg_off);
  digitalWrite(dE, e ? seg_on : seg_off);
  digitalWrite(dF, f ? seg_on : seg_off);
  digitalWrite(dG, g ? seg_on : seg_off);
  digitalWrite(dP, dp? seg_on : seg_off);
}

static inline void drawDigit(uint8_t val, bool dp) {
  if (val == 0xFF) { setSegments(false,false,false,false,false,false,false, dp); return; }
  switch (val) {
    case 0: setSegments(true, true, true, true, true, true, false, dp); break;
    case 1: setSegments(false,true, true, false,false,false,false, dp); break;
    case 2: setSegments(true, true, false,true, true, false, true, dp); break;
    case 3: setSegments(true, true, true, true, false,false, true, dp); break;
    case 4: setSegments(false,true, true, false,false, true, true, dp); break;
    case 5: setSegments(true, false,true, true, false, true, true, dp); break;
    case 6: setSegments(true, false,true, true, true, true, true, dp); break;
    case 7: setSegments(true, true, true, false,false,false,false, dp); break;
    case 8: setSegments(true, true, true, true, true, true, true, dp); break;
    case 9: setSegments(true, true, true, true, false, true, true, dp); break;
    default:setSegments(false,false,false,false,false,false,false, dp); break;
  }
}

static inline void allDigitsOff() {
  digitalWrite(dig1, dig_off);
  digitalWrite(dig2, dig_off);
  digitalWrite(dig3, dig_off);
}

void IRAM_ATTR displayISR() {
  portENTER_CRITICAL_ISR(&dispMux);
  allDigitsOff();
  currentDigit = (currentDigit + 1) % 3;
  uint8_t val = disp_digits[currentDigit];
  bool    dp  = disp_dp[currentDigit];
  drawDigit(val, dp);
  switch (currentDigit) {
    case 0: digitalWrite(dig1, dig_on); break;
    case 1: digitalWrite(dig2, dig_on); break;
    case 2: digitalWrite(dig3, dig_on); break;
  }
  portEXIT_CRITICAL_ISR(&dispMux);
}

static void updateDisplayFromTemp(float t) {
  int t10 = (int)roundf(t * 10.0f);
  if (t10 < 0) t10 = 0;
  if (t10 > 999) t10 = 999;
  int tens   = (t10 / 100) % 10;
  int ones   = (t10 / 10)  % 10;
  int tenths =  t10 % 10;
  portENTER_CRITICAL(&dispMux);
  disp_digits[0] = (t10 >= 100) ? tens : 0xFF;
  disp_digits[1] = ones;
  disp_digits[2] = tenths;
  disp_dp[0] = false;
  disp_dp[1] = true;
  disp_dp[2] = false;
  portEXIT_CRITICAL(&dispMux);
}

static void initDisplayPins() {
  pinMode(dA, OUTPUT); pinMode(dB, OUTPUT); pinMode(dC, OUTPUT); pinMode(dD, OUTPUT);
  pinMode(dE, OUTPUT); pinMode(dF, OUTPUT); pinMode(dG, OUTPUT); pinMode(dP, OUTPUT);
  pinMode(dig1, OUTPUT); pinMode(dig2, OUTPUT); pinMode(dig3, OUTPUT);
  setSegments(false,false,false,false,false,false,false,false);
  allDigitsOff();
}

static void initDisplayTimer() {
  dispTimer = timerBegin(0, 80, true);
  timerAttachInterrupt(dispTimer, &displayISR, true);
  timerAlarmWrite(dispTimer, 1000, true);
  timerAlarmEnable(dispTimer);
}

static bool  filt_init = false;
static float temp_filt = 0.0f;

static const float ALPHA        = 0.2f;
static const float MAX_STEP     = 1.5f;
static const float HARD_OUTLIER = 20.0f;
static const int   NSAMPLES     = 8;

static const float OFFSET_C     = 6.5f;

static float readTempRawC() {
  long acc = 0;
  for (int k = 0; k < NSAMPLES; ++k) {
    acc += analogRead(sensor_pin);
    delayMicroseconds(1500);
  }
  float meanADC = acc / (float)NSAMPLES;
  float millivolts = meanADC * (3300.0f / 4095.0f);
  float tC = (millivolts / 10.0f) + OFFSET_C;
  return tC;
}

static float readTempFilteredC() {
  float t_raw = readTempRawC();
  if (!filt_init) {
    temp_filt = t_raw;
    filt_init = true;
    return temp_filt;
  }
  float delta = t_raw - temp_filt;
  if (fabsf(delta) > HARD_OUTLIER) {
    return temp_filt;
  }
  if (delta >  MAX_STEP) t_raw = temp_filt + MAX_STEP;
  if (delta < -MAX_STEP) t_raw = temp_filt - MAX_STEP;
  temp_filt = (ALPHA * t_raw) + ((1.0f - ALPHA) * temp_filt);
  return temp_filt;
}

void setup() {
  Serial.begin(115200);
  Serial.println("Connecting to Adafruit IO...");
  io.connect();
  while (io.status() < AIO_CONNECTED) {
    Serial.print(".");
    delay(500);
  }
  Serial.println();
  Serial.println(io.statusText());
  pinMode(bot1, INPUT_PULLDOWN);
  initDisplayPins();
  updateDisplayFromTemp(0.0f);
  initDisplayTimer();
  analogSetPinAttenuation(sensor_pin, ADC_11db);
  ledcSetup(0, 5000, 8);   ledcAttachPin(led_v, 0);
  ledcSetup(1, 5000, 8);   ledcAttachPin(led_a, 1);
  ledcSetup(2, 5000, 8);   ledcAttachPin(led_r, 2);
  ledcSetup(ch_servo, servo_freq, servo_res);
  ledcAttachPin(servo_pin, ch_servo);
  writeServoAngle(90.0f);
  temp_filt = readTempFilteredC();
}

void loop() {
  io.run();
  const unsigned long now = millis();
  if (now - lastUpdate >= IO_LOOP_DELAY) {
    Serial.print("Sending.. ");
    Serial.println(temp_filt);
    feed_proyecto->save(temp_filt);
    lastUpdate = now;
  }
  int reading = digitalRead(bot1);
  if (reading != last_bot_state) {
    last_time = millis();
  }
  if ((millis() - last_time) > deb_delay) {
    if (reading != bot_state) {
      bot_state = reading;
      if (bot_state == HIGH) {
        float tC = readTempFilteredC();
        temp = tC;
        temp_disp = roundf(temp * 10.0f) / 10.0f;
        Serial.print("Temperatura : ");
        Serial.println(temp_disp, 1);
        if (temp_disp < 22.0) {
          led_v_pwm = 255;  
          led_a_pwm = 0;   
          led_r_pwm = 0;
        } else if (temp_disp >= 22.0 && temp_disp < 25.0) {
          led_v_pwm = 0;    
          led_a_pwm = 255; 
          led_r_pwm = 0;
        } else {
          led_v_pwm = 0;    
          led_a_pwm = 0;   
          led_r_pwm = 255;
        }
        ledcWrite(0, led_v_pwm);
        ledcWrite(1, led_a_pwm);
        ledcWrite(2, led_r_pwm);
        float angle = 90.0f;
        if (temp_disp < 22.0) angle = 0.0f;
        else if (temp_disp < 25.0) angle = 90.0f;
        else angle = 180.0f;
        writeServoAngle(angle);
        Serial.print("angulo servo: ");
        Serial.println(angle);
        updateDisplayFromTemp(temp_disp);
        delay(100);
      }
    }
  }
  last_bot_state = reading;
}
